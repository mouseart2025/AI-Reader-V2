# Story N30.2: 模拟退火全局标签优化 + 高清地图导出

Status: draft

## Story

As a 用户,
I want 点击"导出全图"按钮获得一张所有地名错落有致、排版精美的高清地图图片,
So that 我可以保存、分享、打印小说的世界地图，具有出版级的排版质量。

## Background

N30.1 的多锚点偏移是实时交互优化（贪心算法，毫秒级），但对于静态导出场景，可以投入更多计算时间（秒级）来获得全局最优的标签排布。

研究报告（维度4）指出模拟退火（Simulated Annealing）是注记布局的行业标准方法，D3-labeler 等库已有成熟实现。核心思想：定义能量函数（重叠惩罚 + 偏移惩罚 + 遮挡惩罚），随机扰动标签位置，按 Metropolis 准则接受/拒绝，温度逐步降低到零。

## Acceptance Criteria

1. **AC-1**: MapPage 工具栏新增"导出全图"按钮（图标：Download），点击触发导出流程
2. **AC-2**: 导出时对所有地点（不受 minMentions/tier 折叠限制）运行模拟退火标签布局，计算全局最优标签位置
3. **AC-3**: 模拟退火能量函数包含三项：标签间重叠面积（权重最高）、标签偏离默认锚点距离（权重中）、标签遮挡节点图标面积（权重中）
4. **AC-4**: 退火参数：初始温度 T₀=1.0，冷却率 α=0.995，最大迭代 5000 次，每次随机选一个标签移动到新候选位置
5. **AC-5**: 退火过程中显示进度条（"正在优化标签布局... 60%"）
6. **AC-6**: 导出格式为 PNG（默认）和 SVG（可选），分辨率为当前画布的 3x（约 4800x2700）
7. **AC-7**: 导出的图片包含完整的地形底图 + 领地 + 地点图标 + 优化后标签 + 图例
8. **AC-8**: 导出图片底部添加小号水印文字："Generated by AI Reader V2"

## Tasks / Subtasks

- [ ] Task 1: 模拟退火标签优化器
  - [ ] 1.1 新建 `lib/labelAnnealing.ts`，实现 `annealLabels(items, canvasW, canvasH) → Map<string, LabelPlacement>`
  - [ ] 1.2 能量函数 `computeEnergy(placements)`：扫描所有标签对的重叠面积 + 偏移距离 + 图标遮挡
  - [ ] 1.3 扰动函数 `perturb(placements)`：随机选一个标签，在其 8 个候选锚点中随机切换，或微调 ±offset
  - [ ] 1.4 退火循环：T = T₀, while T > 0.001 且 iter < maxIter: perturb → ΔE → 接受概率 exp(-ΔE/T) → T *= α
  - [ ] 1.5 返回最终 placements

- [ ] Task 2: 导出管线
  - [ ] 2.1 MapPage 新增 `handleExport()` handler
  - [ ] 2.2 导出时创建离屏 SVG（3x 分辨率），渲染完整地图（所有地点，无过滤）
  - [ ] 2.3 对离屏 SVG 运行模拟退火标签优化
  - [ ] 2.4 SVG 导出：直接序列化 SVG DOM 为 `.svg` 文件
  - [ ] 2.5 PNG 导出：SVG → Canvas → toBlob → 下载

- [ ] Task 3: UI 交互
  - [ ] 3.1 MapPage 控件区新增"导出全图"按钮
  - [ ] 3.2 导出过程中按钮变为 disabled + spinner
  - [ ] 3.3 进度条组件展示退火进度百分比
  - [ ] 3.4 完成后自动触发浏览器下载

## Dev Notes

### 模拟退火伪代码

```typescript
function annealLabels(items: LabelItem[], W: number, H: number): Map<string, LabelPlacement> {
  let placements = initializeWithMultiAnchor(items) // S1 的贪心结果作为初始状态
  let energy = computeEnergy(placements)
  let T = 1.0
  const alpha = 0.995

  for (let i = 0; i < 5000 && T > 0.001; i++) {
    const candidate = perturb(placements)
    const newEnergy = computeEnergy(candidate)
    const dE = newEnergy - energy
    if (dE < 0 || Math.random() < Math.exp(-dE / T)) {
      placements = candidate
      energy = newEnergy
    }
    T *= alpha
  }
  return placements
}
```

### SVG 导出技术

利用 `XMLSerializer().serializeToString(svgNode)` 获取 SVG 字符串。PNG 导出使用 `createImageBitmap()` + OffscreenCanvas 或传统 `Image()` + Canvas 方式。注意：外部图片（地形 PNG）需内联为 data URI。

### 退火初始状态

使用 N30.1 的多锚点贪心结果作为退火的初始状态（warm start），这比随机初始化快得多。
